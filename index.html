<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Relational N-Back ‚Äî Logic-Only N-Match (Voice + Visual)</title>
<style>
:root { --bg:#0b0d10; --fg:#e6fbff; --a:#00ccff; --mut:#8fe7ff }
*{ box-sizing:border-box }
body{ font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; background:var(--bg); color:var(--fg); margin:0; padding:16px }
.wrap{ max-width:1160px; margin:0 auto }
.row{ display:flex; gap:12px; flex-wrap:wrap }
.col{ flex:1 1 360px }
.box{ background:#101418; border:1px solid rgba(0,200,255,.25); border-radius:14px; padding:12px }
.title{ font-weight:800; margin-bottom:6px; letter-spacing:.3px }
.btn{ background:#0b0d10; color:var(--a); border:1px solid var(--a); border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer }
.btn:disabled{ opacity:.5; cursor:not-allowed }
label{ font-size:12px; color:var(--mut); display:block; margin:6px 0 }
input[type=range],select{ width:100% }
select{ min-height:38px }
.kbd{ border:1px solid rgba(255,255,255,.25); padding:2px 6px; border-radius:6px; background:#0b0d10 }
.mut{ color:var(--mut); font-size:12px }
.badge{ display:inline-block; padding:2px 6px; border:1px solid rgba(0,200,255,.3); border-radius:8px; font-size:12px; color:var(--mut); margin-left:6px }
#premiseText{ margin-top:12px; min-height:90px; background:#0e1113; border:1px solid rgba(0,200,255,.25); border-radius:12px; padding:10px; font-size:18px; line-height:1.6 }
#premiseText .rel{ padding:0 4px; border-radius:6px }
#premiseText .rel.active{ background:rgba(0,200,255,.20); outline:1px solid rgba(0,200,255,.45) }
#premiseText .sep{ opacity:.65 }
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <div class="col">
      <div class="box">
        <div class="title">Timing</div>
        <label>N-back level: <span id="nVal">1</span></label>
        <input id="n" type="range" min="1" max="10" value="1">
        <label>Trials per block: <span id="tVal">40</span></label>
        <input id="trials" type="range" min="10" max="200" step="5" value="40">
        <label>Pause between relations in the same premise (seconds): <span id="pVal">1.0 s</span></label>
        <input id="pauseTime" type="range" min="0" max="60" step="0.5" value="1">
        <label>Target match rate: <span id="rVal">25%</span></label>
        <input id="rate" type="range" min="0" max="100" step="1" value="25">
        <div class="mut">N-matches are computed <b>only</b> from relational logic (vectors + levels). Labels/text never affect matching.</div>
      </div>
    </div>

    <div class="col">
      <div class="box" id="voiceBox">
        <div class="title">Voice <span id="voiceStatus" class="badge">Ready</span></div>
        <label>Country / Region</label>
        <select id="regionSelect"></select>
        <label>Voice</label>
        <select id="voice"></select>
        <div class="mut" id="voiceHint" style="margin-top:6px;">Menus fill instantly; they‚Äôll auto-update if the system exposes more voices.</div>
        <label style="margin-top:10px">Rate: <span id="rateVal">0.95</span></label>
        <input id="vRate" type="range" min="0.7" max="1.6" step="0.01" value="0.95">
        <label>Pitch: <span id="pitchVal">1.28</span></label>
        <input id="vPitch" type="range" min="0.7" max="2" step="0.01" value="1.28">
        <label>Volume: <span id="vVolVal">1.00</span></label>
        <input id="vVol" type="range" min="0" max="1" step="0.05" value="1.0">
        <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
          <button id="testVoice" class="btn" type="button">Test voice</button>
          <button id="refreshVoices" class="btn" type="button">Refresh</button>
        </div>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Controls / Status</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px">
          <button id="start" class="btn">‚ñ∂ Start</button>
          <button id="pause" class="btn" disabled>‚è∏ Pause</button>
          <button id="reset" class="btn" disabled>üîÑ Reset</button>
          <button id="hit" class="btn" disabled>‚úì Match (<span class="kbd">M</span>)</button>
          <button id="skip" class="btn" disabled>‚è≠ Skip</button>
        </div>
        <div class="mut" style="margin-top:8px">
          Trial <span id="idx">0</span>/<span id="max">40</span> ‚Ä¢ Planned: <span id="ptype">‚Äî</span> ‚Ä¢ Actual: <span id="isMatch">‚Äî</span>
        </div>
        <div class="mut">Correct: <span id="corr">0</span> ‚Ä¢ Errors: <span id="err">0</span></div>
      </div>
    </div>
  </div>

  <div class="box" style="margin-top:12px">
    <div class="title">Premise (spoken + visual)</div>
    <div id="premiseText" aria-live="polite">‚Äî</div>
  </div>
</div>

<script>
/* ===================== helpers ===================== */
const $ = id => document.getElementById(id);
const sleep = ms => new Promise(r=>setTimeout(r,ms));

/* ===================== directions ===================== */
const DIRS = {
  north:{x:0,y:-1}, south:{x:0,y:1}, east:{x:1,y:0}, west:{x:-1,y:0},
  northeast:{x:1,y:-1}, northwest:{x:-1,y:-1}, southeast:{x:1,y:1}, southwest:{x:-1,y:1}
};
const HORIZ = Object.keys(DIRS);
const LEVELS = [1,2,3];

/* ===================== female-only voice loader (strict, labeled, region-correct) ===================== */
let VOICE=null; let running=false; let paused=false; // running/paused also used by gameplay
let pendingVoiceRefresh=false; // don't hot-swap during speech
let pendingVoiceKey=null;      // apply user change at premise boundary
const LAST_KEY='rnback_last_voice_v2';

// --- Robust loader: prime + wait until voices actually appear (many browsers are lazy) ---
async function ensureVoicesReady(maxWait=5000){
  if(!('speechSynthesis' in window)) return [];
  let list = voicesNow();
  if(list.length) return list;
  // Prime with a couple of silent utterances to force voice catalogs to hydrate
  try{
    for(let i=0;i<2;i++){ const u=new SpeechSynthesisUtterance(' '); u.volume=0; speechSynthesis.speak(u); }
  }catch(_){ }
  // Wait for onvoiceschanged OR poll as a fallback
  return await new Promise(resolve=>{
    let done=false; const finish=()=>{ if(!done){ done=true; resolve(voicesNow()); } };
    const start=Date.now();
    const iv=setInterval(()=>{ const now=voicesNow(); if(now.length || Date.now()-start>maxWait){ clearInterval(iv); finish(); } }, 60);
    try{ speechSynthesis.onvoiceschanged = ()=>{ const now=voicesNow(); if(now.length){ clearInterval(iv); finish(); } }; }catch(_){ }
  });
}
async function hydrateVoicesAndPopulate(){ await ensureVoicesReady(); populateMenusStrict(); }

const REGION_NAMES={ AE:'United Arab Emirates', AU:'Australia', GB:'United Kingdom', UK:'United Kingdom',
  US:'United States', CA:'Canada', NZ:'New Zealand', IE:'Ireland', IN:'India', ZA:'South Africa',
  PH:'Philippines', SG:'Singapore', HK:'Hong Kong', NG:'Nigeria'
};
const regionCode=lang=>(String(lang).match(/^[a-z]{2,3}[-_]?([A-Z]{2})/)||[])[1]||'';
const regionName=lang=> (regionCode(lang)==='AE' ? 'United Arab Emirates'
                         : REGION_NAMES[regionCode(lang)] || (/^en\b/i.test(lang)?'Global English':'Other Region'));

// Robust name/gender heuristics (Web Speech API does not expose gender)
const FEMALE_TOKENS=/\b(zira|samantha|karen|moira|tessa|serena|veena|victoria|joanna|jenny|aria|jessa|kimberly|kendra|ivy|nicole|salli|olivia|ella|ava|amy|emma|mia|sophia|isabella|natasha|catherine|allison|chloe|grace|zoe|sarah|sofia|camila|paulina|luciana|monica|anna|tatyana|zhiyu|hazel|helen|riva|luna|maya|noor|nour|layla|leila|hala|mariam|maryam|salma|dana|rania|yasmin|yasmine|amal|reem|farah|fatima|fatma|huda|nada|noura|nura|susan|sonia|sonya|cortana|hannah|lila|lily|kate|grace)\b/i;
const MALE_NEG=/\b(male|boy|man|alex(?!a)|daniel|david|george|michael|mark|tom|fred|brian|kevin|liam|adam|andy|ben|bruce|charles|chris\b|eric|frank|jack|john|luke|matt|mike|nathan|paul|peter|ryan|steve|tim|james|william|robert|andrew|henry|richard|pablo|ricardo|mateo|rahul|ravi|neil|noah|sam(?!antha))\b/i;

function voicesNow(){ try{ return speechSynthesis.getVoices()||[]; }catch(_){ return []; } }
function vKey(v){ return v.voiceURI||(v.name+'|'+v.lang); }

function vendorOf(v){ const n=v.name||''; const u=v.voiceURI||''; if(/^Microsoft\b/i.test(n)) return 'Microsoft'; if(/^Google\b/i.test(n)) return 'Google'; if(/com\.apple\./i.test(u)) return 'Apple'; return 'System'; }

function canonicalName(v){
  const vendor=vendorOf(v);
  let name=v.name||'';
  if(vendor==='Microsoft'){
    // e.g., "Microsoft Zira Desktop - English (United States)"
    name=name.replace(/^Microsoft\s+/i,'').replace(/\s+(Desktop|Online)(?:\s*\(Natural\))?/i,'')
             .replace(/\s*-\s*English.*$/i,'').trim();
  }
  if(vendor==='Google'){
    // Keep Google‚Äôs name (e.g., "Google UK English Female")
    name=name.trim();
  }
  if(vendor==='Apple'){
    // Apple names are already pretty clean (Karen, Samantha, Tessa, ...)
    name=name.trim();
  }
  // Fallback to voiceURI tail if empty
  if(!name){ const m=(v.voiceURI||'').match(/([\w-]+)$/); if(m) name=m[1]; }
  return name;
}

function isExplicitFemale(v){
  const n=(v.name+' '+v.voiceURI).toLowerCase();
  if(/\bfemale\b/.test(n)) return true;
  if(FEMALE_TOKENS.test(n)) return true;
  if(MALE_NEG.test(n)) return false;
  // Apple known female set by name + region
  const knownAppleFemale=new Set(['samantha','karen','tessa','moira','serena','veena','victoria']);
  if(/com\.apple\./i.test(v.voiceURI||'') && knownAppleFemale.has((v.name||'').toLowerCase())) return true;
  return false;
}

function properLabel(v){
  const region=regionName(v.lang);
  const code=regionCode(v.lang);
  const vendor=vendorOf(v);
  const name=canonicalName(v);
  return `${name} ‚Äî ${region}${code?` (${code})`:''} (${vendor})`;
}

function chooseBestVoice(list){
  try{
    const last=localStorage.getItem(LAST_KEY);
    if(last){ const found=list.find(v=>vKey(v)===last); if(found) return found; }
  }catch(_){}}
  // Prefer AU then GB then US female voices
  const order=[/en[-_]?AU/i,/en[-_]?GB/i,/en[-_]?US/i];
  for(const re of order){ const f=list.find(v=>re.test(v.lang)); if(f) return f; }
  return list[0]||null;
}

function populateMenusStrict(){
  const voiceSel=$('voice'); const regionSel=$('regionSelect');
  voiceSel.innerHTML=''; regionSel.innerHTML='';

  const raw=voicesNow();
  const females=raw.filter(isExplicitFemale);
  const pool = females.length ? females
    : raw.filter(v => /^en[-_]/i.test(v.lang||'') && !MALE_NEG.test((v.name+' '+v.voiceURI)));

  // Build regions only where female voices exist
  const groups=new Map();
  for(const v of pool){ const r=regionName(v.lang); if(!groups.has(r)) groups.set(r,[]); groups.get(r).push(v); }

  const regionsOrder=['Australia','United Kingdom','United States','Ireland','India','South Africa','United Arab Emirates','Canada','New Zealand','Singapore','Philippines','Hong Kong','Global English','Other Region'];
  const regions=regionsOrder.filter(r=>groups.has(r));

  if(regions.length===0){
    const o=document.createElement('option'); o.value=''; o.textContent='‚Äî No female voices found on this system ‚Äî'; voiceSel.appendChild(o);
    voiceSel.disabled=true; regionSel.disabled=true; $('voiceStatus').textContent='No female voices';
    $('start').disabled=true; return;
  }

  regions.forEach(r=>{ const o=document.createElement('option'); o.value=r; o.textContent=r; regionSel.appendChild(o); });
  regionSel.value = regions.includes('Australia') ? 'Australia' : regions[0];

  function fillVoicesFor(region){
    voiceSel.innerHTML='';
    const pack=groups.get(region)||[];
    pack.forEach(v=>{ const o=document.createElement('option'); o.value=vKey(v); o.textContent=properLabel(v); o.title=`${v.name} ‚Äî ${regionName(v.lang)} ‚Äî ${v.lang}`; voiceSel.appendChild(o); });
    voiceSel.disabled = pack.length===0;
    const best=chooseBestVoice(pack);
    if(best){ VOICE=best; voiceSel.value=vKey(best); try{localStorage.setItem(LAST_KEY,vKey(best));}catch(_){}}
  }

  fillVoicesFor(regionSel.value);

  regionSel.onchange=()=>fillVoicesFor(regionSel.value);
  voiceSel.onchange=()=>{ const key=voiceSel.value; const found=voicesNow().find(v=>vKey(v)===key); if(found){ if(running) pendingVoiceKey=key; else { VOICE=found; try{localStorage.setItem(LAST_KEY,vKey(found));}catch(_){}} } };

  if('speechSynthesis' in window){
    speechSynthesis.onvoiceschanged = ()=>{ if(running){ pendingVoiceRefresh=true; } else { populateMenusStrict(); } };
  }

  $('voiceStatus').textContent='Ready';
}

function applyVoiceDefaults(){ $('vRate').value=0.95; $('rateVal').textContent='0.95'; $('vPitch').value=1.28; $('pitchVal').textContent='1.28'; }

async function warmupTTS(){ try{ const u=new SpeechSynthesisUtterance(' '); u.volume=0; if(VOICE) u.voice=VOICE; speechSynthesis.speak(u); await sleep(60);}catch(_){}}

/* Speaking: lock a single snapshot voice per premise to prevent mid-utterance switching */
async function speak(text, voiceSnap){
  if(!('speechSynthesis' in window)) return;
  const u=new SpeechSynthesisUtterance(text);
  const v=voiceSnap||VOICE; if(v) u.voice=v; u.lang=(v&&v.lang)||'en-AU';
  u.rate=+$('vRate').value; u.pitch=+$('vPitch').value; u.volume=+$('vVol').value;
  return new Promise(res=>{ let done=false; const finish=()=>{ if(!done){ done=true; res(); }}; u.onend=finish; u.onerror=finish; try{ speechSynthesis.speak(u); const guard=Math.min(12000, 250+Math.ceil(60*Math.max(1,text.length)/Math.max(0.5,u.rate||1))); setTimeout(finish,guard);}catch(_){ finish(); } });
}

/* ===================== strict relational logic (reversible) ===================== */
const LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ';
const token=()=> LETTERS[Math.floor(Math.random()*26)] + (1+Math.floor(Math.random()*9));
function uniqueTokens(k){ const s=new Set(); while(s.size<k) s.add(token()); return [...s]; }

function parsePremise(sentence){
  const parts=String(sentence).split(/\s+and\s+/i).map(p=>p.trim()).filter(Boolean);
  const edges=[]; const nodes=new Set();
  for(const part of parts){
    let m=part.match(/^([A-Z]\d+)\s+is\s+(one|two|three|1|2|3)\s*(?:levels?)?\s+(above|below)\s+(?:of\s+)?([A-Z]\d+)$/i);
    if(m){
      const u=m[1], v=m[4];
      const nTxt=m[2].toLowerCase();
      const n=nTxt==='one'?1:nTxt==='two'?2:nTxt==='three'?3:+nTxt;
      const z=m[3].toLowerCase()==='above'? n : -n;
      edges.push({u,v,rel:{x:0,y:0,z}});
      nodes.add(u); nodes.add(v); continue;
    }
    m=part.match(/^([A-Z]\d+)\s+is\s+(north(?:east|west)?|south(?:east|west)?|east|west)\s+of\s+([A-Z]\d+)$/i);
    if(m){
      const u=m[1], v=m[3], dir=m[2].toLowerCase();
      const vec=DIRS[dir]; if(!vec) continue;
      edges.push({u,v,rel:{x:vec.x,y:vec.y,z:0}});
      nodes.add(u); nodes.add(v); continue;
    }
  }
  return {nodes:[...nodes], edges};
}
function invertRel(r){ return {x:-r.x, y:-r.y, z:-r.z}; }
function canonEdge(u,v,rel){ if(u<=v){ return {a:u, b:v, rel:`${rel.x},${rel.y},${rel.z}`}; } const ri=invertRel(rel); return {a:v, b:u, rel:`${ri.x},${ri.y},${ri.z}`}; }
function multisetKey(e){ return `${e.a}|${e.b}|${e.rel}`; }
function edgesToMultiset(edges){ const map=new Map(); for(const e of edges){ const ce=canonEdge(e.u,e.v,e.rel); const k=multisetKey(ce); map.set(k,(map.get(k)||0)+1); } return map; }
function equalMultisets(A,B){ if(A.size!==B.size) return false; for(const [k,v] of A){ if(B.get(k)!==v) return false; } return true; }
function permutations(arr){ const res=[], used=Array(arr.length).fill(false), path=[]; (function dfs(){ if(path.length===arr.length){ res.push(path.slice()); return; } for(let i=0;i<arr.length;i++){ if(used[i])continue; used[i]=true; path.push(arr[i]); dfs(); path.pop(); used[i]=false; } })(); return res; }
function sentencesCompatible(a,b){ const A=parsePremise(a), B=parsePremise(b); if(A.edges.length!==B.edges.length) return false; if(A.nodes.length!==B.nodes.length) return false; const nodesA=A.nodes.slice().sort(), nodesB=B.nodes.slice().sort(); const Ams=edgesToMultiset(A.edges); for(const perm of permutations(nodesA)){ const map=new Map(); for(let i=0;i<nodesB.length;i++) map.set(nodesB[i], perm[i]); const mapped=B.edges.map(e=>({u:map.get(e.u), v:map.get(e.v), rel:e.rel})); const Bms=edgesToMultiset(mapped); if(equalMultisets(Ams,Bms)) return true; } return false; }

/* ===================== builders ===================== */
function clauseString(from, rel, to){ if(rel.z){ const n=Math.abs(rel.z), word=n===1?'one level':n===2?'two levels':'three levels'; return `${from} is ${word} ${rel.z>0?'above':'below'} ${to}`; } else { const d = Object.entries(DIRS).find(([k,v])=>v.x===rel.x && v.y===rel.y)[0]; return `${from} is ${d} of ${to}`; } }
function randomPremise(){ const [A,B,C]=uniqueTokens(3); const pick=()=> Math.random()<0.6 ? {k:'h',d:HORIZ[Math.floor(Math.random()*HORIZ.length)]} : {k:'v',n:LEVELS[Math.floor(Math.random()*LEVELS.length)],up:Math.random()<0.5}; const c=(X,r,Y)=> r.k==='h' ? `${X} is ${r.d} of ${Y}` : `${X} is ${r.n} ${r.n===1?'level':'levels'} ${r.up?'above':'below'} ${Y}`; const r1=pick(), r2=pick(); return `${c(A,r1,B)} and ${c(B,r2,C)}`; }
function buildCompatible(sentence){ const P=parsePremise(sentence); const uniq=[...new Set(P.edges.flatMap(e=>[e.u,e.v]))].length; const labels=uniqueTokens(uniq); const map=new Map(); let i=0; const parts=P.edges.map(({u,v,rel})=>{ if(!map.has(u)) map.set(u,labels[i++]); if(!map.has(v)) map.set(v,labels[i++]); return clauseString(map.get(u),rel,map.get(v)); }); for(let j=parts.length-1;j>0;j--){ const k=Math.floor(Math.random()*(j+1)); [parts[j],parts[k]]=[parts[k],parts[j]]; } return parts.join(' and '); }

/* ===================== TTS verbalization ===================== */
function sayToken(tok){ const m=tok.match(/^([A-Z])(\d+)$/); if(!m) return tok; const digits={'0':'zero','1':'one','2':'two','3':'three','4':'four','5':'five','6':'six','7':'seven','8':'eight','9':'nine'}; return `${m[1]} ${m[2].split('').map(d=>digits[d]||d).join(' ')}`; }
function splitDiag(dir){ return dir.replace(/northeast/gi,'north east').replace(/northwest/gi,'north west').replace(/southeast/gi,'south east').replace(/southwest/gi,'south west'); }
function verbalizeClause(clause){
  let m=clause.match(/^([A-Z]\d+)\s+is\s+(one|two|three|1|2|3)\s*(?:levels?)?\s+(above|below)\s+(?:of\s+)?([A-Z]\d+)$/i);
  if(m){ const left=sayToken(m[1]); const n=+({one:1,two:2,three:3}[m[2].toLowerCase()] ?? m[2]); const word=n===1?'one level':n===2?'two levels':'three levels'; const right=sayToken(m[4]); return `${left} is ${word} ${m[3].toLowerCase()} ${right}`; }
  m=clause.match(/^([A-Z]\d+)\s+is\s+(north(?:east|west)?|south(?:east|west)?|east|west)\s+of\s+([A-Z]\d+)$/i);
  if(m){ return `${sayToken(m[1])} is ${splitDiag(m[2])} of ${sayToken(m[3])}`; }
  return clause;
}
function verbalizeSentence(s){ return s.split(/\s+and\s+/i).map(p=>verbalizeClause(p.trim())); }

/* ===================== gameplay ===================== */
let N=1, MAX=40, PAUSE_SEC=1.0, RATE=25;
let idx=0; let waitTimer=null; const history=[], planned=[]; let correct=0, errors=0; let spokenParts=null, clauseIdx=0;

function planSequence(){ planned.length=0; for(let i=0;i<MAX;i++){ planned.push(i>=N && Math.random()*100 < RATE); } }
function isActualMatch(i){ return i>=N && sentencesCompatible(history[i-N], history[i]); }

function buildPremiseVisual(raw){ const parts=raw.split(/\s+and\s+/i).map(p=>p.trim()); const el=$('premiseText'); el.innerHTML=''; parts.forEach((part,i)=>{ const sp=document.createElement('span'); sp.className='rel'; sp.textContent=part; el.appendChild(sp); if(i<parts.length-1){ const sep=document.createElement('span'); sep.className='sep'; sep.textContent=' and '; el.appendChild(sep); } }); return parts; }
function setActivePart(i){ [...$('premiseText').querySelectorAll('.rel')].forEach((n,idx)=>n.classList.toggle('active', idx===i)); }

// Speak all parts using a single voice snapshot + trailing pause
async function speakPremise(){
  if(!spokenParts) return;
  const voiceSnap = VOICE; // lock for the whole premise
  for(; running && !paused && clauseIdx<spokenParts.length; clauseIdx++){
    setActivePart(clauseIdx);
    await speak(spokenParts[clauseIdx]+'.', voiceSnap);
    if(!running || paused) return;
    if(clauseIdx<spokenParts.length-1){ await new Promise(res=>{ waitTimer=setTimeout(()=>{waitTimer=null; res(); }, PAUSE_SEC*1000); }); await sleep(30); }
  }
  setActivePart(-1);
  if(running && !paused){ await new Promise(res=>{ waitTimer=setTimeout(()=>{waitTimer=null; res(); }, PAUSE_SEC*1000); }); await sleep(30); }
}

function maybeApplyPendingVoice(){ if(pendingVoiceKey){ const found=voicesNow().find(v=>vKey(v)===pendingVoiceKey); if(found){ VOICE=found; try{localStorage.setItem(LAST_KEY,vKey(found));}catch(_){}} pendingVoiceKey=null; } if(pendingVoiceRefresh){ pendingVoiceRefresh=false; populateMenusStrict(); } }

function nextPremiseString(){ const want=planned[idx] && idx>=N; if(want) return buildCompatible(history[idx-N]); let s, tries=0; do{ s=randomPremise(); tries++; } while(idx>=N && sentencesCompatible(history[idx-N], s) && tries<300); if(idx>=N && sentencesCompatible(history[idx-N], s)){ const P=parsePremise(s); if(P.edges.length){ const e=P.edges[0]; if(e.rel.z){ e.rel.z*=-1; } else { e.rel.x*=-1; e.rel.y*=-1; } s=P.edges.map(ed=>clauseString(ed.u, ed.rel, ed.v)).join(' and '); } } return s; }

async function runTrial(){ if(!running || paused) return; if(idx>=MAX){ stop(); return; } const s=nextPremiseString(); history[idx]=s; buildPremiseVisual(s); spokenParts=verbalizeSentence(s); clauseIdx=0; await speakPremise(); if(!running || paused) return; maybeApplyPendingVoice(); idx++; updateUI(); runTrial(); }

/* ===================== controls ===================== */
function start(){ if(running) return; running=true; paused=false; try{speechSynthesis.cancel();}catch(_){ } planSequence(); idx=0; correct=0; errors=0; updateUI(); $('pause').disabled=false; $('reset').disabled=false; $('hit').disabled=false; $('skip').disabled=false; runTrial(); }
function stop(){ running=false; paused=false; clearTimeout(waitTimer); waitTimer=null; spokenParts=null; clauseIdx=0; try{ speechSynthesis.cancel(); }catch(_){} $('pause').disabled=true; $('skip').disabled=true; }
function togglePause(){ if(!running && !paused) return; if(!paused){ paused=true; clearTimeout(waitTimer); waitTimer=null; try{ speechSynthesis.cancel(); }catch(_){} $('pause').textContent='‚ñ∂ Resume'; } else { paused=false; $('pause').textContent='‚è∏ Pause'; if(spokenParts && clauseIdx<spokenParts.length){ speakPremise().then(()=>{ if(running && !paused){ maybeApplyPendingVoice(); idx++; updateUI(); runTrial(); } }); } else { maybeApplyPendingVoice(); idx++; updateUI(); runTrial(); } } }
function reset(){ stop(); $('start').disabled=false; $('pause').textContent='‚è∏ Pause'; idx=0; correct=0; errors=0; $('premiseText').textContent='‚Äî'; updateUI(); }
function registerHit(){ if(!running) return; if(isActualMatch(idx)) correct++; else errors++; updateUI(); }
function skip(){ if(!running) return; clearTimeout(waitTimer); try{speechSynthesis.cancel();}catch(_){} maybeApplyPendingVoice(); idx++; updateUI(); runTrial(); }
function updateUI(){ $('idx').textContent=idx; $('max').textContent=MAX; $('ptype').textContent = planned[idx] && idx>=N ? 'planned MATCH' : 'planned NON-match'; $('isMatch').textContent = idx>=N ? String(isActualMatch(idx)).toUpperCase() : '‚Äî'; $('corr').textContent=correct; $('err').textContent=errors; $('nVal').textContent=N; $('tVal').textContent=MAX; $('pVal').textContent=PAUSE_SEC.toFixed(1)+' s'; $('rVal').textContent=RATE+'%'; }

/* ===================== bindings ===================== */
$('start').onclick = async ()=>{
  if(!VOICE){
    await hydrateVoicesAndPopulate();
    const rawPool=voicesNow();
    let pool=rawPool.filter(isExplicitFemale);
    if(!pool.length){ pool = rawPool.filter(v => /^en[-_]/i.test(v.lang||'') && !MALE_NEG.test((v.name+' '+v.voiceURI))); }
    const best=chooseBestVoice(pool);
    if(best){ VOICE=best; try{localStorage.setItem(LAST_KEY,vKey(best));}catch(_){}}
  }
  await warmupTTS();
  await speak('Ready.', VOICE);
  start();
};
$('pause').onclick=togglePause; $('reset').onclick=reset; $('hit').onclick=registerHit; $('skip').onclick=skip; window.addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='m') registerHit(); });

// sliders
$('n').oninput=e=>{ N=+e.target.value; $('nVal').textContent=N; };
$('trials').oninput=e=>{ MAX=+e.target.value; $('tVal').textContent=MAX; $('max').textContent=MAX; };
$('pauseTime').oninput=e=>{ PAUSE_SEC=+e.target.value; $('pVal').textContent=PAUSE_SEC.toFixed(1)+' s'; };
$('rate').oninput=e=>{ RATE=+e.target.value; $('rVal').textContent=RATE+'%'; };

// voice UI init
$('refreshVoices').onclick=()=>hydrateVoicesAndPopulate();
$('testVoice').onclick=async()=>{ if(!VOICE) await hydrateVoicesAndPopulate(); await warmupTTS(); await speak('Voice check. Example: C three is north east of H seven.', VOICE); };

/* ===================== immediate paint ===================== */
document.addEventListener('DOMContentLoaded', ()=>{ hydrateVoicesAndPopulate(); applyVoiceDefaults(); $('voiceStatus').textContent='Ready'; });
</script>
</body>
</html>
